<!-- Forked from https://bl.ocks.org/getflourish/8b3eeb3076bc3e20099de7f2ef9186b8 -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Colony Reputation Tree Visualizer</title>
  </head>

  <body>

    <!-- Load Dependencies -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

    <!-- Page HTML -->
    <div id="app">

      <!-- UI controls that can are used to manipulate the display of the chart -->
<!--       <div class="controls">

        <div>
          <label>Miner port</label>
          <input type="text" v-model="minerPort" />
        </div>

          <div>
            <label>Chart width</label>
            <input type="range" v-model="settings.width" min="0" max="1000" />
          </div>

          <div>
            <label>Stroke color</label>
            <input type="color" v-model="settings.strokeColor" />
          </div>

      </div> -->

      <!-- SVG that renders the chart based on the "width" and "height" setting from the Vue instance’s data object -->
      <svg v-bind:width="settings.width" v-bind:height="settings.height">

      <!-- In contrast to D3’s "select" methods, we define the graphical elements explicitly here and use the template syntax to loop through collections and bind properties such as "d" or "r" to those elements. -->
        <transition-group tag="g" name="line" transform="translate(50,0)">

          <!-- Links are represented as paths -->
          <path v-for="link in links" class="link" v-bind:key="link.id" v-bind:d="link.d" v-bind:style="link.style"></path>

        </transition-group>

        <!-- We can now also use events to elements that will call respective methods on the Vue instance -->
        <transition-group tag="g" name="list" transform="translate(50,0)">
          <g class="node" v-on:click="select(index, node)" v-for="(node, index) in nodes" v-bind:key="node.id" v-bind:style="node.style" v-bind:class="[node.className, {'highlight': node.highlight}]">

            <!-- Circles for each node -->
            <circle v-bind:r="node.r" style="{'fill': '#bfbfbf'}"></circle>

            <!-- Finally, text labels -->
            <text v-bind:dx="node.textpos.x" v-bind:dy="node.textpos.y" v-bind:style="node.textStyle">{{ node.text }}</text>

          </g>
        </transition-group>
      </svg>
    </div>

    <script type="text/javascript">

      new Vue({
      el: "#app",
      data: function() {
        return {
          minerPort: "3000",
          repData: null,
          settings: {
            strokeColor: "#19B5FF",
            width: 1200,
            height: 1000
          }
        };
      },
      mounted: function() {
        const that = this;
        d3.request(`http://localhost:${that.minerPort}/reputations`, function(error, res) {
          if (error) throw error;

          const reputations = JSON.parse(res.response);
          reputations.forEach(d => { d.id = d.userAddress.substring(1) });

          const parents = that.parents(reputations);

          const stratify = d3.stratify()
            .id(function(d) { return d.id + (d.decimalValue ? "~" : ""); })
            .parentId(function(d) { return d.id.substring(0, d.id.length - (d.decimalValue ? 0 : 1)); });

          that.repData = stratify(reputations.concat(parents))
            .sort(function(a, b) { return a.height - b.height || a.id.localeCompare(b.id); });
        });
      },
      computed: {
        // Instead of enter, update, exit, we mainly use computed properties and instead of "d3.data()" we can use array.map to create objects that hold class names, styles, and other attributes for each datum
        root: function() {
          const that = this;
          if (this.repData) {
            const tree = d3.tree()
              .size([that.settings.height, that.settings.width - 100]);
            return tree(this.repData);
          }
        },
        nodes: function() {
          const that = this;
          if (this.root) {
            return this.root.descendants().map(function(d) {
              return {
                id: d.id,
                r: 2.5,
                className: "node" + (d.children ? " node-internal" : " node-leaf"),
                text: d.id.indexOf("~") > 0 ? d.data.decimalValue / 10 ** 18 : d.id.substring(d.id.length - 1),
                style: { transform: "translate(" + d.y + "px," + d.x + "px)" },
                textpos: { x: d.children ? -8 : 8, y: 3 },
                textStyle: { textAnchor: d.children ? "end" : "start" }
              };
            });
          }
        },
        links: function() {
          const that = this;
          if (this.root) {
            // here we’ll calculate the "d" attribute for each path that is then used in the template where we use "v-for" to loop through all of the links to create <path> elements
            return this.root.descendants().slice(1).map(function(d) {
              return {
                id: d.id,
                d: "M" + d.parent.y + "," + d.parent.x
                  + "C" + (d.y + d.parent.y) / 2 + "," + d.parent.x
                  + " " + (d.y + d.parent.y) / 2 + "," + d.x
                  + " " + d.y + "," + d.x,
                // here we could of course calculate colors depending on data but for now all links share the same color from the settings object that we can manipulate using UI controls and v-model
                style: {
                  stroke: that.settings.strokeColor
                }
              };
            });
          }
        }
      },
      methods: {
        parents: function(nodes) {
          const parentSet = new Set();
          for (let i = 0; i < nodes[0].id.length; i++) {
            nodes.forEach(function(d) { parentSet.add(d.id.substring(0, d.id.length - i)); });
          }
          return Array.from(parentSet).map(function(d) { return { id: d }});
        },
        select: function(index, node) {
          const realNode = this.repData.descendants()[index];
          if (realNode.children) {
            realNode._children = realNode.children;
            realNode.children = null;
          } else {
            realNode.children = realNode._children;
            realNode._children = null;
          }
        }
      }
    });
    </script>

    <style>

      body {
        width: 100%;
        height: 100%;
        font-family: monospace;
      }

      .controls {
        position: fixed;
        top: 16px;
        left: 16px;
        background: #f8f8f8;
        padding: 0.5rem;
        display: flex;
        flex-direction: column;
      }

      .controls > * + * {
        margin-top: 1rem;
      }

      .node {
        opacity: 1;
      }

      .node circle {
        fill: #999;
        cursor: pointer;
      }

      .node text {
        font: 10px sans-serif;
        cursor: pointer;
      }

      .node-internal circle {
        fill: #555;
      }

      .node-internal text {
        text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
      }

      .link {
        fill: none;
        stroke: #555;
        stroke-opacity: 0.4;
        stroke-width: 1.5px;
        stroke-dasharray: 1000;
      }

      .node:hover {
        pointer-events: all;
        stroke: #ff0000;
      }

      .node.highlight {
        fill: red;
      }

      label {
        display: block;
      }

      .list-enter-active, .list-leave-active {
        transition: all 2s;
      }
      .list-enter, .list-leave-to /* .list-leave-active for <2.1.8 */ {
        opacity: 0;
        transform: translateY(30px);
      }

      .line-enter-active, .line-leave-active {
        transition: all 2s;
        stroke-dashoffset: 0;
      }
      .line-enter, .line-leave-to /* .list-leave-active for <2.1.8 */ {
        stroke-dashoffset: 1000;
      }

    </style>
  </body>
</html>
